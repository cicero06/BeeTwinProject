const SensorReading = require('../models/SensorReading');
const Sensor = require('../models/Sensor');
const mongoose = require('mongoose');
const { broadcastSensorData } = require('./websocket');
const MLProcessor = require('./mlProcessor');

// LoRa verisi i≈üleme sƒ±nƒ±fƒ±
class LoRaDataProcessor {
    constructor(io) {
        this.io = io; // WebSocket instance
        this.mlProcessor = new MLProcessor(); // üß† ML Processor entegrasyonu
    }

    // Router ID'sine g√∂re sensor types belirle - G√úNCEL TEST KOVALI
    getSensorTypesByRouter(routerId) {
        const routerConfigs = {
            // AKTIF √áALI≈ûAN ROUTERLAR
            '107': ['temperature', 'humidity', 'pressure', 'altitude'], // BMP280 - Router 107, Sensor 1013
            '108': ['co', 'no2'],                           // MICS-4514 - Router 108, Sensor 1002

            // GELECEKTE EKLENECEKLERƒ∞ (HAZIR OLSUN)
            '109': ['weight', 'load'],                       // Load Sensor - Router 109, Sensor 1010  
            '110': ['gas', 'smoke', 'lpg']                   // MQ2 Gas - Router 110, Sensor 1009
        };

        return routerConfigs[routerId] || ['temperature', 'humidity']; // Default sensors
    }

    // üéØ PERMANENT SOLUTION: Router configuration auto-update
    async ensureRouterConfiguration(hive, routerId, sensorId) {
        try {
            const Hive = require('../models/Hive');

            // Router configuration mapping
            const routerTypeMap = {
                '107': { type: 'bmp280', address: '41', sensorIds: ['1013'], dataKeys: ['temperature', 'humidity', 'pressure'] },
                '108': { type: 'mics4514', address: '52', sensorIds: ['1002'], dataKeys: ['co', 'no2'] },
                '109': { type: 'loadcell', address: '66', sensorIds: ['1010'], dataKeys: ['weight', 'load'] },
                '110': { type: 'mq2', address: '58', sensorIds: ['1009'], dataKeys: ['gas', 'smoke', 'lpg'] }
            };

            const routerConfig = routerTypeMap[routerId];
            if (!routerConfig) {
                console.log('‚ö†Ô∏è Unknown router ID:', routerId);
                return;
            }

            // Check if hardwareDetails exists and if this router is already configured
            const existingRouter = hive.hardwareDetails?.routers?.find(r => r.routerId === routerId);

            if (!existingRouter) {
                console.log('üîß Adding router configuration to hive:', routerId);

                // Initialize hardwareDetails structure if needed
                const updateData = {
                    $push: {
                        'hardwareDetails.routers': {
                            routerId: routerId,
                            routerType: routerConfig.type,
                            address: routerConfig.address,
                            sensorIds: routerConfig.sensorIds,
                            dataKeys: routerConfig.dataKeys,
                            isActive: true,
                            lastSeen: new Date()
                        }
                    }
                };

                // If hardwareDetails structure doesn't exist, initialize it
                if (!hive.hardwareDetails) {
                    updateData.$set = {
                        'hardwareDetails': {
                            coordinatorAddress: null,
                            channel: 23,
                            routers: [{
                                routerId: routerId,
                                routerType: routerConfig.type,
                                address: routerConfig.address,
                                sensorIds: routerConfig.sensorIds,
                                dataKeys: routerConfig.dataKeys,
                                isActive: true,
                                lastSeen: new Date()
                            }]
                        }
                    };
                    delete updateData.$push; // Remove push operation if we're setting the whole structure
                }

                await Hive.findByIdAndUpdate(hive._id, updateData);
                console.log('‚úÖ Router configuration added:', routerId, '‚Üí Type:', routerConfig.type);
            } else {
                // Update lastSeen for existing router
                await Hive.findOneAndUpdate(
                    {
                        _id: hive._id,
                        'hardwareDetails.routers.routerId': routerId
                    },
                    {
                        $set: {
                            'hardwareDetails.routers.$.lastSeen': new Date(),
                            'hardwareDetails.routers.$.isActive': true
                        }
                    }
                );
            }

        } catch (error) {
            console.error('‚ùå Router configuration error:', error.message);
        }
    }

    // Sens√∂r var olup olmadƒ±ƒüƒ±nƒ± kontrol et ve gerekirse olu≈ütur
    async ensureSensorExists(wirelessData, hive, routerId, sensorId) {
        try {
            // Device ID ile sensor ara
            let sensor = await Sensor.findOne({ deviceId: wirelessData.deviceId });

            if (sensor) {
                console.log('‚úÖ Existing sensor found:', sensor.deviceId, 'Router:', routerId);
                return sensor;
            }

            // Sens√∂r tipi belirle
            const sensorTypes = this.getSensorTypesByRouter(routerId);

            if (!hive || !hive.apiary) {
                console.log('‚ö†Ô∏è Creating basic sensor without hive association for device:', wirelessData.deviceId);

                // Ge√ßici test kullanƒ±cƒ±sƒ± bilgileri
                const testUserId = new mongoose.Types.ObjectId('507f1f77bcf86cd799439011');
                const testApiaryId = new mongoose.Types.ObjectId('507f1f77bcf86cd799439022');

                sensor = await Sensor.create({
                    deviceId: wirelessData.deviceId,
                    name: `Test Sensor - ${wirelessData.deviceId}`,
                    ownerId: testUserId,
                    apiaryId: testApiaryId,
                    sensorTypes: sensorTypes,
                    status: 'active',
                    batteryLevel: wirelessData.batteryLevel || 85
                });
                console.log('‚úÖ Test sensor created:', sensor.deviceId, 'Router:', routerId, 'Types:', sensorTypes);
                return sensor;
            }

            // Ger√ßek kovan bilgileri ile sens√∂r olu≈ütur
            sensor = await Sensor.create({
                deviceId: wirelessData.deviceId,
                name: `${hive.name} - ${wirelessData.deviceId}`,
                ownerId: hive.apiary.ownerId, // üéØ GER√áEK KULLANICI ID
                apiaryId: hive.apiary._id,    // üéØ GER√áEK ARILIK ID
                sensorTypes: sensorTypes,
                status: 'active',
                batteryLevel: wirelessData.batteryLevel || 85
            });
            console.log('‚úÖ New sensor created with real owner:', sensor.deviceId, 'Router:', routerId, 'Types:', sensorTypes);

            return sensor;

        } catch (error) {
            console.error('‚ùå Sensor creation error:', error.message);
            console.error('Error details:', error.stack);
            return null;
        }
    }

    // Wireless veriyi i≈üle
    async processWirelessData(wirelessData) {
        try {
            console.log('üì° Processing wireless data:', wirelessData.deviceId);

            // Device ID'den router ID √ßƒ±kar (BT107 ‚Üí 107)
            const routerId = wirelessData.deviceId.replace('BT', '');

            // Koordinat√∂r sistemde hive aramasƒ±
            const Hive = require('../models/Hive');
            const hive = await Hive.findOne({
                'hardwareDetails.routers.routerId': routerId
            }).populate('apiary');

            // Hive varsa router configuration'ƒ± g√ºncelle
            if (hive) {
                await this.ensureRouterConfiguration(hive, routerId, '1013'); // Default sensor ID
            }

            // Sens√∂r var olup olmadƒ±ƒüƒ±nƒ± kontrol et
            const sensor = await this.ensureSensorExists(wirelessData, hive, routerId, '1013');
            if (!sensor) {
                console.log('‚ùå Sensor creation failed for:', wirelessData.deviceId);
                return null;
            }

            // Son veri ile kar≈üƒ±la≈ütƒ±r (anomali tespiti i√ßin)
            const lastReading = await SensorReading.findOne({
                sensorId: sensor._id
            }).sort({ timestamp: -1 });

            // SensorReading olu≈ütur (Battery ve Signal Strength eklendi)
            const readingData = {
                sensorId: sensor._id,
                data: wirelessData.sensorData,
                timestamp: wirelessData.originalTimestamp || wirelessData.receivedAt,
                batteryLevel: wirelessData.batteryLevel,   // üîã Coordinator'dan gelen
                signalStrength: wirelessData.signalStrength, // üì∂ Coordinator'dan gelen
                metadata: {
                    receivedAt: wirelessData.receivedAt,
                    dataInterval: '10min',
                    source: 'wireless'
                }
            };

            // üß† ML Analysis - Geli≈ümi≈ü analiz
            const historicalData = await this.mlProcessor.getHistoricalData(wirelessData.deviceId, 30);
            const mlResults = await this.mlProcessor.analyzeData({
                deviceId: wirelessData.deviceId,
                sensorData: wirelessData.sensorData,
                historicalData: historicalData
            });

            // ML sonu√ßlarƒ±nƒ± metadata'ya ekle
            readingData.metadata.mlAnalysis = mlResults;

            // Klasik anomali tespiti (backward compatibility)
            if (lastReading) {
                const basicAnomalies = this.detectAnomalies(lastReading.data, wirelessData.sensorData);
                if (basicAnomalies.length > 0) {
                    readingData.metadata.basicAnomalies = basicAnomalies;
                    console.log('‚ö†Ô∏è Basic anomalies detected:', basicAnomalies);
                }
            }

            // Database'e kaydet
            const savedReading = await SensorReading.create(readingData);
            console.log('üíæ Wireless sensor reading saved:', savedReading._id);

            // Sens√∂r bilgilerini g√ºncelle
            await Sensor.findByIdAndUpdate(sensor._id, {
                batteryLevel: wirelessData.batteryLevel,
                lastSeen: wirelessData.receivedAt,
                status: wirelessData.batteryLevel > 20 ? 'active' : 'low_battery'
            });

            // Alert kontrol√º (ML sonu√ßlarƒ± dahil)
            await this.checkForAlerts(sensor, savedReading, mlResults);

            // WebSocket ile frontend'e g√∂nder (ML insights dahil)
            broadcastSensorData(this.io, {
                ...savedReading.toObject(),
                ownerId: sensor.ownerId,
                sensorName: sensor.name,
                deviceId: sensor.deviceId,
                mlInsights: mlResults // üß† ML sonu√ßlarƒ± frontend'e
            });

            return savedReading;

        } catch (error) {
            console.error('‚ùå Wireless data processing error:', error.message);
            console.error('üìã Error stack:', error.stack);
            console.error('üîç Error details:', {
                name: error.name,
                message: error.message,
                deviceId: wirelessData?.deviceId,
                routerId: wirelessData?.deviceId?.replace('BT', '')
            });
            return null;
        }
    }

    // Anomali tespiti
    detectAnomalies(lastData, currentData) {
        const anomalies = [];
        const thresholds = {
            temperature: 10, // 10¬∞C ani deƒüi≈üim
            humidity: 30,    // 30% ani deƒüi≈üim
            weight: 5        // 5kg ani deƒüi≈üim
        };

        for (const [key, value] of Object.entries(currentData)) {
            if (lastData[key] !== undefined && typeof value === 'number') {
                const diff = Math.abs(value - lastData[key]);
                const threshold = thresholds[key] || 50; // Default threshold

                if (diff > threshold) {
                    anomalies.push({
                        field: key,
                        previousValue: lastData[key],
                        currentValue: value,
                        difference: diff,
                        threshold: threshold
                    });
                }
            }
        }

        return anomalies;
    }

    // Alert kontrol√º
    async checkForAlerts(sensor, reading, mlResults = null) {
        // Implementation here
    }

    // Raw LoRa payload parse
    parseLoRaPayload(rawData) {
        try {
            // Hex string kontrol√º
            if (typeof rawData === 'string' && /^[0-9A-Fa-f]+$/.test(rawData)) {
                const buffer = Buffer.from(rawData, 'hex');
                return this.parseByteArray(buffer);
            }

            return null;
        } catch (error) {
            console.error('‚ùå LoRa payload parse error:', error.message);
            return null;
        }
    }

    // Text format parse
    parseTextFormat(rawData) {
        try {
            console.log('üîç Parsing text format:', rawData);

            if (!rawData || typeof rawData !== 'string') {
                console.log('‚ùå Invalid text data format');
                return null;
            }

            // Format: "RID:107 SID:1013 WT:25.50 PR:1013.25 WH:65.00"
            const parts = rawData.split(' ').filter(part => part.trim().length > 0);

            if (parts.length < 3) {
                console.log('‚ùå Insufficient data parts:', parts.length);
                return null;
            }

            // RID parse et
            const ridPart = parts[0].trim(); // "RID:107"
            const routerId = ridPart.split(':')[1].trim(); // "107"

            // SID parse et
            const sidPart = parts[1].trim(); // " SID:1013"
            const sensorId = sidPart.split(':')[1].trim(); // "1013"

            // Data parse et
            const sensorData = {};
            for (let i = 2; i < parts.length; i++) {
                const dataPart = parts[i].trim();
                if (dataPart.includes(':')) {
                    const [key, value] = dataPart.split(':');
                    const numValue = parseFloat(value);
                    if (!isNaN(numValue)) {
                        sensorData[key] = numValue;
                    }
                }
            }

            // Device ID olu≈ütur
            const deviceId = `BT${routerId}`;

            const result = {
                deviceId: deviceId,
                routerId: routerId,
                sensorId: sensorId,
                sensorData: sensorData,
                receivedAt: new Date(),
                originalTimestamp: new Date(),
                batteryLevel: 85, // Default
                signalStrength: -70 // Default
            };

            console.log('‚úÖ Text format parsed successfully:', result);
            return result;

        } catch (error) {
            console.error('‚ùå Text format parse error:', error.message);
            return null;
        }
    }
}

module.exports = LoRaDataProcessor;
